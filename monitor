#!/usr/bin/env python3

import subprocess
import time
import sys
import os
import re
from pathlib import Path
from datetime import datetime
import json

POLL_INTERVAL = 30  # seconds
MAX_SCRIPT_LINES = 50


def get_webhook_url():
    url = os.getenv("NOTIFIER_URL")
    if not url:
        print("❌ Environment variable NOTIFIER_URL not set.")
        sys.exit(1)
    return url


def send_slack(text: str):
    url = get_webhook_url()
    # Build a Block Kit payload for mrkdwn formatting
    payload = {
        "blocks": [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": text
                }
            }
        ]
    }
    # Use --data-raw to send unaltered JSON; json.dumps escapes properly
    subprocess.run([
        "curl", "-X", "POST",
        "-H", "Content-Type: application/json; charset=utf-8",
        "--data-raw", json.dumps(payload),
        url
    ], check=True)


def extract_jobid(output: str):
    match = re.search(r"Submitted batch job (\d+)", output)
    return match.group(1) if match else None


def monitor_sbatch(cmd: list):
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if result.returncode != 0:
        print("sbatch failed:\n", result.stderr)
        send_slack(f"❌ sbatch failed:\n```{result.stderr.strip()}```")
        sys.exit(1)

    print(result.stdout.strip())
    jobid = extract_jobid(result.stdout)
    if not jobid:
        print("❌ Failed to extract job ID from sbatch output.")
        sys.exit(1)

    script_path = Path(cmd[1]) if len(cmd) > 1 and Path(cmd[1]).exists() else None
    if script_path:
        with open(script_path) as f:
            script_content = "".join(f.readlines()[:MAX_SCRIPT_LINES])
    else:
        script_content = f"(Script file not found: {cmd[1]})"

    while True:
        try:
            squeue_out = subprocess.run(["squeue", "-j", jobid], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
            if jobid not in squeue_out.stdout:
                break
            time.sleep(POLL_INTERVAL)
        except KeyboardInterrupt:
            print("\nMonitoring interrupted.")
            sys.exit(1)

    host = os.uname().nodename
    pwd = os.getcwd()
    send_slack(
        f"✅ *Slurm job* `{jobid}` finished on `{host}`\n"
        f"*{pwd}*\n"
        f"*Command:* `{' '.join(cmd)}`\n"
        f"```\n{script_content.strip()}\n```"
    )


def monitor_command(cmd_str: str):
    proc = subprocess.Popen(cmd_str, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, 
                          env=os.environ, text=True, shell=True)
    combined_output, _ = proc.communicate()

    host = os.uname().nodename
    pwd = os.getcwd()
    output = combined_output.strip() or "(no output)"
    output_msg = f"✅ *<{host}|{host}:>*\n_{pwd}_\n`{cmd_str}`\n```\n{output}\n```"

    send_slack(output_msg)


def main():
    if len(sys.argv) < 2:
        print("Usage: monitor <command>")
        sys.exit(1)

    if not os.environ.get('NOUP_RUNNING'):
        # Join all args into a single string
        cmd_str = ' '.join(sys.argv[1:])
        os.environ['NOUP_RUNNING'] = '1'
        # Pass the command as a single quoted string
        subprocess.Popen(
            f'nohup {sys.executable} {__file__} "{cmd_str}" > /dev/null 2>&1 &',
            shell=True,
            env=os.environ
        )
        print(f"Started monitoring in background")
        sys.exit(0)

    # Now sys.argv[1] is the full command string
    cmd_str = sys.argv[1]
    monitor_command(cmd_str)


if __name__ == "__main__":
    main()
